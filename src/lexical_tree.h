#ifndef LEXICAL_TREE_H
#define LEXICAL_TREE_H

#include "symbol.h"
#include "vector.h"

typedef enum {
  SYNTAX_KIND_RANGE_LITERAL_BEGIN,
  SYNTAX_KIND_IDENTIFIER = SYNTAX_KIND_RANGE_LITERAL_BEGIN,
  SYNTAX_KIND_INTEGER,
  SYNTAX_KIND_STRING,
  SYNTAX_KIND_RANGE_LITERAL_END,

  SYNTAX_KIND_RANGE_PUNCTUATION_BEGIN = SYNTAX_KIND_RANGE_LITERAL_END,
  SYNTAX_KIND_PLUS                    = SYNTAX_KIND_RANGE_PUNCTUATION_BEGIN,
  SYNTAX_KIND_MINUS,
  SYNTAX_KIND_STAR,
  SYNTAX_KIND_EQUAL,
  SYNTAX_KIND_NOT_EQUAL,
  SYNTAX_KIND_LESS_THAN,
  SYNTAX_KIND_LESS_THAN_EQUAL,
  SYNTAX_KIND_GREATER_THAN,
  SYNTAX_KIND_GREATER_THAN_EQUAL,
  SYNTAX_KIND_LEFT_PARENTHESIS,
  SYNTAX_KIND_RIGHT_PARENTHESIS,
  SYNTAX_KIND_LEFT_BRACKET,
  SYNTAX_KIND_RIGHT_BRACKET,
  SYNTAX_KIND_ASSIGN,
  SYNTAX_KIND_DOT,
  SYNTAX_KIND_COMMA,
  SYNTAX_KIND_COLON,
  SYNTAX_KIND_SEMICOLON,
  SYNTAX_KIND_RANGE_PUNCTUATION_END,

  SYNTAX_KIND_RANGE_KEYWORD_BEGIN = SYNTAX_KIND_RANGE_PUNCTUATION_END,
  SYNTAX_KIND_KEYWORD_PROGRAM     = SYNTAX_KIND_RANGE_KEYWORD_BEGIN,
  SYNTAX_KIND_KEYWORD_VAR,
  SYNTAX_KIND_KEYWORD_ARRAY,
  SYNTAX_KIND_KEYWORD_OF,
  SYNTAX_KIND_KEYWORD_BEGIN,
  SYNTAX_KIND_KEYWORD_END,
  SYNTAX_KIND_KEYWORD_IF,
  SYNTAX_KIND_KEYWORD_THEN,
  SYNTAX_KIND_KEYWORD_ELSE,
  SYNTAX_KIND_KEYWORD_PROCEDURE,
  SYNTAX_KIND_KEYWORD_RETURN,
  SYNTAX_KIND_KEYWORD_CALL,
  SYNTAX_KIND_KEYWORD_WHILE,
  SYNTAX_KIND_KEYWORD_DO,
  SYNTAX_KIND_KEYWORD_NOT,
  SYNTAX_KIND_KEYWORD_OR,
  SYNTAX_KIND_KEYWORD_DIV,
  SYNTAX_KIND_KEYWORD_AND,
  SYNTAX_KIND_KEYWORD_CHAR,
  SYNTAX_KIND_KEYWORD_INTEGER,
  SYNTAX_KIND_KEYWORD_BOOLEAN,
  SYNTAX_KIND_KEYWORD_READ,
  SYNTAX_KIND_KEYWORD_WRITE,
  SYNTAX_KIND_KEYWORD_READLN,
  SYNTAX_KIND_KEYWORD_WRITELN,
  SYNTAX_KIND_KEYWORD_TRUE,
  SYNTAX_KIND_KEYWORD_FALSE,
  SYNTAX_KIND_KEYWORD_BREAK,
  SYNTAX_KIND_RANGE_KEYWORD_END,

  SYNTAX_KIND_RANGE_GRAMMER_BEGIN = SYNTAX_KIND_RANGE_KEYWORD_END,
  SYNTAX_KIND_PROGRAM             = SYNTAX_KIND_RANGE_GRAMMER_BEGIN,
  SYNTAX_KIND_BLOCK,
  SYNTAX_KIND_VARIABLE_DECLARATOIN,
  SYNTAX_KIND_VARIABLE_NAMES,
  SYNTAX_KIND_TYPE,
  SYNTAX_KIND_STANDARD_TYPE,
  SYNTAX_KIND_ARRAY_TYPE,
  SYNTAX_KIND_SUBPROGRAM_DECLARATION,
  SYNTAX_KIND_FORMAL_PARAMETERS,
  SYNTAX_KIND_COMPOUND_STATEMENT,
  SYNTAX_KIND_STATEMENT,
  SYNTAX_KIND_CONDITION_STATEMENT,
  SYNTAX_KIND_ITERATION_STATEMENT,
  SYNTAX_KIND_EXIT_STATEMENT,
  SYNTAX_KIND_CALL_STATEMENT,
  SYNTAX_KIND_EXPRESSIONS,
  SYNTAX_KIND_RETURN_STATEMENT,
  SYNTAX_KIND_ASSIGNMENT_STATEMENT,
  SYNTAX_KIND_LEFT_PART,
  SYNTAX_KIND_VARIABLE,
  SYNTAX_KIND_EXPRESSION,
  SYNTAX_KIND_SIMPLE_EXPRESSION,
  SYNTAX_KIND_TERM,
  SYNTAX_KIND_FACTOR,
  SYNTAX_KIND_CONSTANT,
  SYNTAX_KIND_MULTIPLICATIVE_OPERATOR,
  SYNTAX_KIND_ADDITIVE_OPERATOR,
  SYNTAX_KIND_RELATIONAL_OPERATOR,
  SYNTAX_KIND_INPUT_STATEMENT,
  SYNTAX_KIND_OUTPUT_STATEMENT,
  SYNTAX_KIND_OUTPUT_FORMAT,
  SYNTAX_KIND_EMPTY_STATEMENT,
  SYNTAX_KIND_RANGE_GRAMMER_END,

  SYNTAX_KIND_SPACE = SYNTAX_KIND_RANGE_GRAMMER_END,
  SYNTAX_KIND_NEWLINE,
  SYNTAX_KIND_BRACES_COMMENT,
  SYNTAX_KIND_C_COMMENT,

  SYNTAX_KIND_ERROR
} SyntaxKind;

typedef struct LexicalTreeNode LexicalTreeNode;
typedef struct LexicalTree     LexicalTree;

struct LexicalTreeNode {
  SyntaxKind kind;

  union {
    Vector children;
    Symbol token;
  } data;
};

struct LexicalTree {
  LexicalTreeNode *root;
};

void lexical_tree_init(LexicalTree *tree, SyntaxKind kind);
void lexical_tree_deinit(LexicalTree *tree);

#endif
