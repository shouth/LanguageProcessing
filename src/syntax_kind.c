#include "syntax_kind.h"
#include <string.h>

typedef struct Keyword Keyword;

struct Keyword {
  const char *keyword;
  SyntaxKind  kind;
};

static Keyword KEYWORDS[] = {
  { "and", SYNTAX_KIND_AND_KEYWORD },
  { "array", SYNTAX_KIND_ARRAY_KEYWORD },
  { "begin", SYNTAX_KIND_BEGIN_KEYWORD },
  { "boolean", SYNTAX_KIND_BOOLEAN_KEYWORD },
  { "break", SYNTAX_KIND_BREAK_KEYWORD },
  { "call", SYNTAX_KIND_CALL_KEYWORD },
  { "char", SYNTAX_KIND_CHAR_KEYWORD },
  { "div", SYNTAX_KIND_DIV_KEYWORD },
  { "do", SYNTAX_KIND_DO_KEYWORD },
  { "else", SYNTAX_KIND_ELSE_KEYWORD },
  { "end", SYNTAX_KIND_END_KEYWORD },
  { "false", SYNTAX_KIND_FALSE_KEYWORD },
  { "if", SYNTAX_KIND_IF_KEYWORD },
  { "integer", SYNTAX_KIND_INTEGER_KEYWORD },
  { "not", SYNTAX_KIND_NOT_KEYWORD },
  { "of", SYNTAX_KIND_OF_KEYWORD },
  { "or", SYNTAX_KIND_OR_KEYWORD },
  { "procedure", SYNTAX_KIND_PROCEDURE_KEYWORD },
  { "program", SYNTAX_KIND_PROGRAM_KEYWORD },
  { "read", SYNTAX_KIND_READ_KEYWORD },
  { "readln", SYNTAX_KIND_READLN_KEYWORD },
  { "return", SYNTAX_KIND_RETURN_KEYWORD },
  { "then", SYNTAX_KIND_THEN_KEYWORD },
  { "true", SYNTAX_KIND_TRUE_KEYWORD },
  { "var", SYNTAX_KIND_VAR_KEYWORD },
  { "while", SYNTAX_KIND_WHILE_KEYWORD },
  { "write", SYNTAX_KIND_WRITE_KEYWORD },
  { "writeln", SYNTAX_KIND_WRITELN_KEYWORD },
};

SyntaxKind syntax_kind_from_keyword(const char *string, unsigned long size)
{
  unsigned long i;
  for (i = 0; i < sizeof(KEYWORDS) / sizeof(Keyword); ++i) {
    if (!strncmp(KEYWORDS[i].keyword, string, size) && !KEYWORDS[i].keyword[size]) {
      return KEYWORDS[i].kind;
    }
  }
  return SYNTAX_KIND_ERROR;
}

int syntax_kind_is_token(SyntaxKind kind)
{
  return kind <= SYNTAX_KIND_EOF_TOKEN;
}

int syntax_kind_is_trivia(SyntaxKind kind)
{
  return kind >= SYNTAX_KIND_SPACE_TRIVIA && kind <= SYNTAX_KIND_C_COMMENT_TRIVIA;
}

static const char *SYNTAX_KIND_TO_STRING[] = {
  "IDENTIFIER_TOKEN",
  "INTEGER_LITERAL",
  "STRING_LITERAL",
  "PLUS_TOKEN",
  "MINUS_TOKEN",
  "STAR_TOKEN",
  "EQUAL_TOKEN",
  "NOT_EQUAL_TOKEN",
  "LESS_THAN_TOKEN",
  "LESS_THAN_EQUAL_TOKEN",
  "GREATER_THAN_TOKEN",
  "GREATER_THAN_EQUAL_TOKEN",
  "LEFT_PARENTHESIS_TOKEN",
  "RIGHT_PARENTHESIS_TOKEN",
  "LEFT_BRACKET_TOKEN",
  "RIGHT_BRACKET_TOKEN",
  "ASSIGN_TOKEN",
  "DOT_TOKEN",
  "COMMA_TOKEN",
  "COLON_TOKEN",
  "SEMICOLON_TOKEN",
  "PROGRAM_KEYWORD",
  "VAR_KEYWORD",
  "ARRAY_KEYWORD",
  "OF_KEYWORD",
  "BEGIN_KEYWORD",
  "END_KEYWORD",
  "IF_KEYWORD",
  "THEN_KEYWORD",
  "ELSE_KEYWORD",
  "PROCEDURE_KEYWORD",
  "RETURN_KEYWORD",
  "CALL_KEYWORD",
  "WHILE_KEYWORD",
  "DO_KEYWORD",
  "NOT_KEYWORD",
  "OR_KEYWORD",
  "DIV_KEYWORD",
  "AND_KEYWORD",
  "CHAR_KEYWORD",
  "INTEGER_KEYWORD",
  "BOOLEAN_KEYWORD",
  "READ_KEYWORD",
  "WRITE_KEYWORD",
  "READLN_KEYWORD",
  "WRITELN_KEYWORD",
  "TRUE_KEYWORD",
  "FALSE_KEYWORD",
  "BREAK_KEYWORD",
  "SPACE_TRIVIA",
  "NEWLINE_TRIVIA",
  "BRACES_COMMENT_TRIVIA",
  "C_COMMENT_TRIVIA",
  "EOF_TOKEN",
  "PROGRAM",
  "VARIABLE_DECLARATION_PART",
  "VARIABLE_DECLARATION",
  "ARRAY_TYPE",
  "PROCEDURE_DECLARATION",
  "FORMAL_PARAMETER_LIST",
  "FORMAL_PARAMETER_SECTION",
  "ASSIGNMENT_STATEMENT",
  "IF_STATEMENT",
  "WHILE_STATEMENT",
  "BREAK_STATEMENT",
  "CALL_STATEMENT",
  "ACTUAL_PARAMETER_LIST",
  "RETURN_STATEMENT",
  "INPUT_STATEMENT",
  "INPUT_LIST",
  "OUTPUT_STATEMENT",
  "OUTPUT_LIST",
  "OUTPUT_VALUE",
  "COMPOUND_STATEMENT",
  "ENTIRE_VARIABLE",
  "INDEXED_VARIABLE",
  "BINARY_EXPRESSION",
  "PARENTHESIZED_EXPRESSION",
  "NOT_EXPRESSION",
  "CAST_EXPRESSION",
  "ERROR",
};

const char *syntax_kind_to_string(SyntaxKind kind)
{
  return SYNTAX_KIND_TO_STRING[kind];
}
